{"version":3,"file":"ui.js","mappings":";;;;;;;;;;AAAa;AACb;AACA,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA;AACA,cAAc,6BAA6B,0BAA0B,cAAc,qBAAqB;AACxG,6IAA6I,cAAc;AAC3J,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,mCAAmC,SAAS;AAC5C,mCAAmC,WAAW,UAAU;AACxD,0CAA0C,cAAc;AACxD;AACA,8GAA8G,OAAO;AACrH,iFAAiF,iBAAiB;AAClG,yDAAyD,gBAAgB,QAAQ;AACjF,+CAA+C,gBAAgB,gBAAgB;AAC/E;AACA,kCAAkC;AAClC;AACA;AACA,UAAU,YAAY,aAAa,SAAS,UAAU;AACtD,oCAAoC,SAAS;AAC7C;AACA;AACA,eAAe,mBAAO,CAAC,wDAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,+BAA+B,YAAY,wBAAwB;AACnE;AACA;AACA,CAAC,IAAI;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA;AACA,6BAA6B,6BAA6B;AAC1D,iBAAiB;AACjB;AACA;AACA;AACA,8BAA8B,gBAAgB;AAC9C,iCAAiC,gBAAgB;AACjD,qBAAqB;AACrB;AACA,8BAA8B,oBAAoB;AAClD,iCAAiC,gBAAgB;AACjD,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8CAA8C;AAC/E,qBAAqB;AACrB;AACA;AACA;AACA;AACA,4CAA4C,wCAAwC;AACpF,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,YAAY,wBAAwB;AACnE;AACA;AACA,KAAK,IAAI;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,mCAAmC,gBAAgB;AAC1F,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,YAAY,wBAAwB;AACnF;AACA;AACA,qBAAqB,IAAI;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;;;;;;AC/KkC;AACL;AACvB;AACP;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yCAAQ;AACpB;AACA;AACA,iBAAiB,6CAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yCAAQ;AACpB;AACA;AACA,iBAAiB,6CAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC,gBAAgB,6CAAY;AAC5B,8BAA8B,gDAAK;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gDAAK;AAChB;AACA;AACA;AACA;AACO;AACP;AACA;AACA,QAAQ,yCAAQ;AAChB;AACA;AACA,aAAa,6CAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC,gBAAgB,6CAAY;AAC5B,uBAAuB,gDAAK;AAC5B;AACA;AACA,WAAW,gDAAK,cAAc;AAC9B;AACA;;;;;;;;;;;;;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjH6C;AACZ;AACE;AACA;AACnC;AACiD;AACN;AACJ;AACF;AACrC;AAC2B;AAC3B;AAC2D;AACV;AACI;AACc;AAClB;AACA;AACjD;AACyC;AACzC;;;;;;;;;;;;;;;;;ACpBmC;AACL;AACe;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gDAAK,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,aAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,sDAAU;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gDAAK,4CAA4C;AAChE;AACA;AACA,eAAe,gDAAK,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA,gBAAgB,6CAAY;AAC5B,kBAAkB,yCAAQ;AAC1B;AACA;AACA;AACA,gBAAgB,yCAAQ;AACxB,4BAA4B,qBAAqB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wBAAwB;AACpD;AACA;AACA,gCAAgC,2BAA2B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,uBAAuB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E;AAC/E,qFAAqF;AACrF,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,+BAA+B;AACnD;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACrYO;AACA;AACP;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACPmC;AACR;AACpB;AACP;AACA;AACA;AACA;AACA;AACA,eAAe,gDAAK;AACpB;AACA;AACA,eAAe,gDAAK,wDAAwD;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gDAAK;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wCAAC;AACpB;AACA;AACA,mBAAmB,wCAAC;AACpB;AACA;AACA;AACA;;;;;;;;;;;;;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;;;;;;;;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,sBAAsB;AAC7B;;;;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;;;;;;;;;;;;;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,sBAAsB;AAC7B;;;;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACjHkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAK;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,wCAAC;AACZ;AACA,gBAAgB,gBAAgB;AAChC;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;ACjD+B;AACI;AACU;AACtC;AACP,gDAAgD,sDAAU;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAK;AACjB;AACA,eAAe,gDAAK;AACpB;AACA;AACA;AACA,eAAe,gDAAK;AACpB;AACA;AACA;AACA,eAAe,gDAAK,QAAQ;AAC5B;AACA;AACA,eAAe,gDAAK,OAAO;AAC3B;AACA;AACA;;;;;;;;;;;;;;ACrDO;AACP;AACA,aAAa;AACb;AACA;;;;;;UCJA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;UENA;UACA;UACA;UACA","sources":["webpack://personalml/./static/input/ui.ts","webpack://personalml/./node_modules/snabbdom/build/h.js","webpack://personalml/./node_modules/snabbdom/build/helpers/attachto.js","webpack://personalml/./node_modules/snabbdom/build/htmldomapi.js","webpack://personalml/./node_modules/snabbdom/build/index.js","webpack://personalml/./node_modules/snabbdom/build/init.js","webpack://personalml/./node_modules/snabbdom/build/is.js","webpack://personalml/./node_modules/snabbdom/build/jsx.js","webpack://personalml/./node_modules/snabbdom/build/modules/attributes.js","webpack://personalml/./node_modules/snabbdom/build/modules/class.js","webpack://personalml/./node_modules/snabbdom/build/modules/dataset.js","webpack://personalml/./node_modules/snabbdom/build/modules/eventlisteners.js","webpack://personalml/./node_modules/snabbdom/build/modules/props.js","webpack://personalml/./node_modules/snabbdom/build/modules/style.js","webpack://personalml/./node_modules/snabbdom/build/thunk.js","webpack://personalml/./node_modules/snabbdom/build/tovnode.js","webpack://personalml/./node_modules/snabbdom/build/vnode.js","webpack://personalml/webpack/bootstrap","webpack://personalml/webpack/runtime/define property getters","webpack://personalml/webpack/runtime/hasOwnProperty shorthand","webpack://personalml/webpack/runtime/make namespace object","webpack://personalml/webpack/before-startup","webpack://personalml/webpack/startup","webpack://personalml/webpack/after-startup"],"sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n    return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar snabbdom = require(\"snabbdom\");\nvar patch = snabbdom.init([\n    snabbdom.classModule,\n    snabbdom.propsModule,\n    snabbdom.styleModule,\n    snabbdom.eventListenersModule,\n]);\n// Initialize global variables\nif (typeof globalThis.data === \"undefined\") {\n    globalThis.data = [];\n}\nfunction ProbabilityBar(_a) {\n    var digit = _a.digit, probability = _a.probability;\n    return snabbdom.h(\"div.group.flex.items-center.space-x-3.w-full.transition-all.duration-300.ease-in-out\", [\n        snabbdom.h(\"div.w-8.text-center.font-semibold.text-gray-600.group-hover:text-blue-600.transition-colors\", digit.toString()),\n        snabbdom.h(\"div.flex-1.bg-gray-200.rounded-full.h-3.overflow-hidden.shadow-inner\", [\n            snabbdom.h(\"div.bg-gradient-to-r.from-blue-500.to-blue-700.h-full.rounded-full.transition-all.duration-500\", {\n                style: {\n                    width: \"\".concat(probability * 100, \"%\"),\n                    opacity: probability > 0 ? 1 : 0.3,\n                },\n            }),\n        ]),\n        snabbdom.h(\"div.w-12.text-right.text-sm.font-medium.text-gray-700.group-hover:text-blue-700.transition-colors\", \"\".concat((probability * 100).toFixed(1), \"%\")),\n    ]);\n}\n// Global state to track predictions\nvar predictions = Array.from({ length: 10 }, function (_, digit) { return ({\n    digit: digit,\n    probability: 0,\n}); });\nfunction view() {\n    return snabbdom.h(\"div.min-h-screen.bg-gradient-to-br.from-gray-100.to-gray-200.flex.items-center.justify-center.p-6\", [\n        snabbdom.h(\"div.bg-white.bg-opacity-80.backdrop-blur-lg.border.border-white.border-opacity-30.rounded-2xl.shadow-2xl.p-8.w-full.max-w-5xl.flex.space-x-8.transform.transition-all.duration-300.hover:scale-[1.01]\", [\n            // Drawing Area\n            snabbdom.h(\"div.w-1/2.flex.flex-col.space-y-6\", [\n                snabbdom.h(\"div.flex.items-center.justify-between.pb-2.border-b.border-gray-200\", [\n                    snabbdom.h(\"h2.text-2xl.font-bold.text-gray-800\", \"Digit Canvas\"),\n                    snabbdom.h(\"div.text-gray-500.hover:text-blue-600.transition-colors.cursor-help\", {\n                        props: {\n                            title: \"Draw a single digit clearly within the canvas\",\n                        },\n                    }, \"ⓘ\"),\n                ]),\n                // Canvas with enhanced styling\n                snabbdom.h(\"canvas#drawingCanvas.bg-white.border-2.border-gray-300.rounded-xl.shadow-md.cursor-crosshair.transition-all.duration-300.hover:shadow-lg\", {\n                    props: { width: \"280\", height: \"280\" },\n                }),\n                // Action Buttons\n                snabbdom.h(\"div.flex.space-x-4\", [\n                    snabbdom.h(\"button#send.flex-1.px-6.py-3.bg-blue-600.text-white.rounded-lg.font-semibold.shadow-md.hover:bg-blue-700.focus:outline-none.focus:ring-2.focus:ring-blue-500.focus:ring-offset-2.transition-all.duration-300.transform.hover:-translate-y-0.5\", {\n                        on: { click: sendata },\n                        props: { type: \"button\" },\n                    }, \"Predict Digit\"),\n                    snabbdom.h(\"button#clear.flex-1.px-6.py-3.bg-gray-200.text-gray-700.rounded-lg.font-semibold.shadow-md.hover:bg-gray-300.focus:outline-none.focus:ring-2.focus:ring-gray-400.focus:ring-offset-2.transition-all.duration-300.transform.hover:-translate-y-0.5\", {\n                        on: { click: clearCanvas },\n                        props: { type: \"button\" },\n                    }, \"Clear Canvas\"),\n                ]),\n            ]),\n            // Probability Display Area\n            snabbdom.h(\"div.w-1/2.bg-gray-50.bg-opacity-50.rounded-xl.p-6.space-y-6.border.border-gray-200\", [\n                // Section Title\n                snabbdom.h(\"div.flex.items-center.justify-between.pb-2.border-b.border-gray-200\", [\n                    snabbdom.h(\"h2.text-2xl.font-bold.text-gray-800\", \"Prediction Confidence\"),\n                    snabbdom.h(\"div.text-gray-500.hover:text-blue-600.transition-colors.cursor-help\", {\n                        props: { title: \"Probability of the digit prediction\" },\n                    }, \"ⓘ\"),\n                ]),\n                // Probability Bars Container\n                snabbdom.h(\"div#probabilityBars.space-y-3\", predictions.map(function (_a) {\n                    var digit = _a.digit, probability = _a.probability;\n                    return ProbabilityBar({ digit: digit, probability: probability });\n                })),\n            ]),\n        ]),\n    ]);\n}\nfunction clearCanvas() {\n    var canvas = document.getElementById(\"drawingCanvas\");\n    var ctx = canvas.getContext(\"2d\");\n    if (ctx) {\n        ctx.fillStyle = \"black\";\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n    }\n    globalThis.data = [];\n    // Reset predictions\n    predictions = Array.from({ length: 10 }, function (_, digit) { return ({\n        digit: digit,\n        probability: 0,\n    }); });\n    // Re-render the view\n    var newNode = view();\n    patch(oldNode, newNode);\n    oldNode = newNode;\n}\nfunction sendata() {\n    return __awaiter(this, void 0, void 0, function () {\n        var response, predictionData_1, newNode, err_1;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    _a.trys.push([0, 3, , 4]);\n                    return [4 /*yield*/, fetch(\"/data\", {\n                            method: \"POST\",\n                            body: JSON.stringify(globalThis.data),\n                            headers: { \"Content-type\": \"application/json; charset=UTF-8\" },\n                        })];\n                case 1:\n                    response = _a.sent();\n                    return [4 /*yield*/, response.json()];\n                case 2:\n                    predictionData_1 = _a.sent();\n                    // Update predictions\n                    predictions = Array.from({ length: 10 }, function (_, digit) { return ({\n                        digit: digit,\n                        probability: predictionData_1[digit] || 0,\n                    }); });\n                    newNode = view();\n                    patch(oldNode, newNode);\n                    oldNode = newNode;\n                    return [3 /*break*/, 4];\n                case 3:\n                    err_1 = _a.sent();\n                    console.error(\"Prediction error:\", err_1);\n                    return [3 /*break*/, 4];\n                case 4: return [2 /*return*/];\n            }\n        });\n    });\n}\nvar oldNode;\ndocument.addEventListener(\"DOMContentLoaded\", function () {\n    oldNode = document.getElementById(\"mainBody\");\n    var newNode = view();\n    patch(oldNode, newNode);\n    oldNode = newNode;\n});\n","import { vnode } from \"./vnode.js\";\nimport * as is from \"./is.js\";\nexport function addNS(data, children, sel) {\n    data.ns = \"http://www.w3.org/2000/svg\";\n    if (sel !== \"foreignObject\" && children !== undefined) {\n        for (let i = 0; i < children.length; ++i) {\n            const child = children[i];\n            if (typeof child === \"string\")\n                continue;\n            const childData = child.data;\n            if (childData !== undefined) {\n                addNS(childData, child.children, child.sel);\n            }\n        }\n    }\n}\nexport function h(sel, b, c) {\n    let data = {};\n    let children;\n    let text;\n    let i;\n    if (c !== undefined) {\n        if (b !== null) {\n            data = b;\n        }\n        if (is.array(c)) {\n            children = c;\n        }\n        else if (is.primitive(c)) {\n            text = c.toString();\n        }\n        else if (c && c.sel) {\n            children = [c];\n        }\n    }\n    else if (b !== undefined && b !== null) {\n        if (is.array(b)) {\n            children = b;\n        }\n        else if (is.primitive(b)) {\n            text = b.toString();\n        }\n        else if (b && b.sel) {\n            children = [b];\n        }\n        else {\n            data = b;\n        }\n    }\n    if (children !== undefined) {\n        for (i = 0; i < children.length; ++i) {\n            if (is.primitive(children[i]))\n                children[i] = vnode(undefined, undefined, undefined, children[i], undefined);\n        }\n    }\n    if (sel.startsWith(\"svg\") &&\n        (sel.length === 3 || sel[3] === \".\" || sel[3] === \"#\")) {\n        addNS(data, children, sel);\n    }\n    return vnode(sel, data, children, text, undefined);\n}\n/**\n * @experimental\n */\nexport function fragment(children) {\n    let c;\n    let text;\n    if (is.array(children)) {\n        c = children;\n    }\n    else if (is.primitive(c)) {\n        text = children;\n    }\n    else if (c && c.sel) {\n        c = [children];\n    }\n    if (c !== undefined) {\n        for (let i = 0; i < c.length; ++i) {\n            if (is.primitive(c[i]))\n                c[i] = vnode(undefined, undefined, undefined, c[i], undefined);\n        }\n    }\n    return vnode(undefined, {}, c, text, undefined);\n}\n//# sourceMappingURL=h.js.map","function pre(vnode, newVnode) {\n    const attachData = vnode.data.attachData;\n    // Copy created placeholder and real element from old vnode\n    newVnode.data.attachData.placeholder = attachData.placeholder;\n    newVnode.data.attachData.real = attachData.real;\n    // Mount real element in vnode so the patch process operates on it\n    vnode.elm = vnode.data.attachData.real;\n}\nfunction post(_, vnode) {\n    // Mount dummy placeholder in vnode so potential reorders use it\n    vnode.elm = vnode.data.attachData.placeholder;\n}\nfunction destroy(vnode) {\n    // Remove placeholder\n    if (vnode.elm !== undefined) {\n        vnode.elm.parentNode.removeChild(vnode.elm);\n    }\n    // Remove real element from where it was inserted\n    vnode.elm = vnode.data.attachData.real;\n}\nfunction create(_, vnode) {\n    const real = vnode.elm;\n    const attachData = vnode.data.attachData;\n    const placeholder = document.createElement(\"span\");\n    // Replace actual element with dummy placeholder\n    // Snabbdom will then insert placeholder instead\n    vnode.elm = placeholder;\n    attachData.target.appendChild(real);\n    attachData.real = real;\n    attachData.placeholder = placeholder;\n}\nexport function attachTo(target, vnode) {\n    if (vnode.data === undefined)\n        vnode.data = {};\n    if (vnode.data.hook === undefined)\n        vnode.data.hook = {};\n    const data = vnode.data;\n    const hook = vnode.data.hook;\n    data.attachData = { target: target, placeholder: undefined, real: undefined };\n    hook.create = create;\n    hook.prepatch = pre;\n    hook.postpatch = post;\n    hook.destroy = destroy;\n    return vnode;\n}\n//# sourceMappingURL=attachto.js.map","function createElement(tagName, options) {\n    return document.createElement(tagName, options);\n}\nfunction createElementNS(namespaceURI, qualifiedName, options) {\n    return document.createElementNS(namespaceURI, qualifiedName, options);\n}\nfunction createDocumentFragment() {\n    return parseFragment(document.createDocumentFragment());\n}\nfunction createTextNode(text) {\n    return document.createTextNode(text);\n}\nfunction createComment(text) {\n    return document.createComment(text);\n}\nfunction insertBefore(parentNode, newNode, referenceNode) {\n    if (isDocumentFragment(parentNode)) {\n        let node = parentNode;\n        while (node && isDocumentFragment(node)) {\n            const fragment = parseFragment(node);\n            node = fragment.parent;\n        }\n        parentNode = node !== null && node !== void 0 ? node : parentNode;\n    }\n    if (isDocumentFragment(newNode)) {\n        newNode = parseFragment(newNode, parentNode);\n    }\n    if (referenceNode && isDocumentFragment(referenceNode)) {\n        referenceNode = parseFragment(referenceNode).firstChildNode;\n    }\n    parentNode.insertBefore(newNode, referenceNode);\n}\nfunction removeChild(node, child) {\n    node.removeChild(child);\n}\nfunction appendChild(node, child) {\n    if (isDocumentFragment(child)) {\n        child = parseFragment(child, node);\n    }\n    node.appendChild(child);\n}\nfunction parentNode(node) {\n    if (isDocumentFragment(node)) {\n        while (node && isDocumentFragment(node)) {\n            const fragment = parseFragment(node);\n            node = fragment.parent;\n        }\n        return node !== null && node !== void 0 ? node : null;\n    }\n    return node.parentNode;\n}\nfunction nextSibling(node) {\n    var _a;\n    if (isDocumentFragment(node)) {\n        const fragment = parseFragment(node);\n        const parent = parentNode(fragment);\n        if (parent && fragment.lastChildNode) {\n            const children = Array.from(parent.childNodes);\n            const index = children.indexOf(fragment.lastChildNode);\n            return (_a = children[index + 1]) !== null && _a !== void 0 ? _a : null;\n        }\n        return null;\n    }\n    return node.nextSibling;\n}\nfunction tagName(elm) {\n    return elm.tagName;\n}\nfunction setTextContent(node, text) {\n    node.textContent = text;\n}\nfunction getTextContent(node) {\n    return node.textContent;\n}\nfunction isElement(node) {\n    return node.nodeType === 1;\n}\nfunction isText(node) {\n    return node.nodeType === 3;\n}\nfunction isComment(node) {\n    return node.nodeType === 8;\n}\nfunction isDocumentFragment(node) {\n    return node.nodeType === 11;\n}\nfunction parseFragment(fragmentNode, parentNode) {\n    var _a, _b, _c;\n    const fragment = fragmentNode;\n    (_a = fragment.parent) !== null && _a !== void 0 ? _a : (fragment.parent = parentNode !== null && parentNode !== void 0 ? parentNode : null);\n    (_b = fragment.firstChildNode) !== null && _b !== void 0 ? _b : (fragment.firstChildNode = fragmentNode.firstChild);\n    (_c = fragment.lastChildNode) !== null && _c !== void 0 ? _c : (fragment.lastChildNode = fragmentNode.lastChild);\n    return fragment;\n}\nexport const htmlDomApi = {\n    createElement,\n    createElementNS,\n    createTextNode,\n    createDocumentFragment,\n    createComment,\n    insertBefore,\n    removeChild,\n    appendChild,\n    parentNode,\n    nextSibling,\n    tagName,\n    setTextContent,\n    getTextContent,\n    isElement,\n    isText,\n    isComment,\n    isDocumentFragment\n};\n//# sourceMappingURL=htmldomapi.js.map","export { htmlDomApi } from \"./htmldomapi.js\";\nexport { init } from \"./init.js\";\nexport { thunk } from \"./thunk.js\";\nexport { vnode } from \"./vnode.js\";\n// helpers\nexport { attachTo } from \"./helpers/attachto.js\";\nexport { array, primitive } from \"./is.js\";\nexport { toVNode } from \"./tovnode.js\";\nexport { h, fragment } from \"./h.js\";\n// types\nexport * from \"./hooks.js\";\n// modules\nexport { attributesModule } from \"./modules/attributes.js\";\nexport { classModule } from \"./modules/class.js\";\nexport { datasetModule } from \"./modules/dataset.js\";\nexport { eventListenersModule } from \"./modules/eventlisteners.js\";\nexport { propsModule } from \"./modules/props.js\";\nexport { styleModule } from \"./modules/style.js\";\n// JSX\nexport { jsx, Fragment } from \"./jsx.js\";\n//# sourceMappingURL=index.js.map","import { vnode } from \"./vnode.js\";\nimport * as is from \"./is.js\";\nimport { htmlDomApi } from \"./htmldomapi.js\";\nfunction isUndef(s) {\n    return s === undefined;\n}\nfunction isDef(s) {\n    return s !== undefined;\n}\nconst emptyNode = vnode(\"\", {}, [], undefined, undefined);\nfunction sameVnode(vnode1, vnode2) {\n    var _a, _b;\n    const isSameKey = vnode1.key === vnode2.key;\n    const isSameIs = ((_a = vnode1.data) === null || _a === void 0 ? void 0 : _a.is) === ((_b = vnode2.data) === null || _b === void 0 ? void 0 : _b.is);\n    const isSameSel = vnode1.sel === vnode2.sel;\n    const isSameTextOrFragment = !vnode1.sel && vnode1.sel === vnode2.sel\n        ? typeof vnode1.text === typeof vnode2.text\n        : true;\n    return isSameSel && isSameKey && isSameIs && isSameTextOrFragment;\n}\n/**\n * @todo Remove this function when the document fragment is considered stable.\n */\nfunction documentFragmentIsNotSupported() {\n    throw new Error(\"The document fragment is not supported on this platform.\");\n}\nfunction isElement(api, vnode) {\n    return api.isElement(vnode);\n}\nfunction isDocumentFragment(api, vnode) {\n    return api.isDocumentFragment(vnode);\n}\nfunction createKeyToOldIdx(children, beginIdx, endIdx) {\n    var _a;\n    const map = {};\n    for (let i = beginIdx; i <= endIdx; ++i) {\n        const key = (_a = children[i]) === null || _a === void 0 ? void 0 : _a.key;\n        if (key !== undefined) {\n            map[key] = i;\n        }\n    }\n    return map;\n}\nconst hooks = [\n    \"create\",\n    \"update\",\n    \"remove\",\n    \"destroy\",\n    \"pre\",\n    \"post\"\n];\nexport function init(modules, domApi, options) {\n    const cbs = {\n        create: [],\n        update: [],\n        remove: [],\n        destroy: [],\n        pre: [],\n        post: []\n    };\n    const api = domApi !== undefined ? domApi : htmlDomApi;\n    for (const hook of hooks) {\n        for (const module of modules) {\n            const currentHook = module[hook];\n            if (currentHook !== undefined) {\n                cbs[hook].push(currentHook);\n            }\n        }\n    }\n    function emptyNodeAt(elm) {\n        const id = elm.id ? \"#\" + elm.id : \"\";\n        // elm.className doesn't return a string when elm is an SVG element inside a shadowRoot.\n        // https://stackoverflow.com/questions/29454340/detecting-classname-of-svganimatedstring\n        const classes = elm.getAttribute(\"class\");\n        const c = classes ? \".\" + classes.split(\" \").join(\".\") : \"\";\n        return vnode(api.tagName(elm).toLowerCase() + id + c, {}, [], undefined, elm);\n    }\n    function emptyDocumentFragmentAt(frag) {\n        return vnode(undefined, {}, [], undefined, frag);\n    }\n    function createRmCb(childElm, listeners) {\n        return function rmCb() {\n            if (--listeners === 0) {\n                const parent = api.parentNode(childElm);\n                if (parent !== null) {\n                    api.removeChild(parent, childElm);\n                }\n            }\n        };\n    }\n    function createElm(vnode, insertedVnodeQueue) {\n        var _a, _b, _c, _d;\n        let i;\n        let data = vnode.data;\n        if (data !== undefined) {\n            const init = (_a = data.hook) === null || _a === void 0 ? void 0 : _a.init;\n            if (isDef(init)) {\n                init(vnode);\n                data = vnode.data;\n            }\n        }\n        const children = vnode.children;\n        const sel = vnode.sel;\n        if (sel === \"!\") {\n            if (isUndef(vnode.text)) {\n                vnode.text = \"\";\n            }\n            vnode.elm = api.createComment(vnode.text);\n        }\n        else if (sel === \"\") {\n            // textNode has no selector\n            vnode.elm = api.createTextNode(vnode.text);\n        }\n        else if (sel !== undefined) {\n            // Parse selector\n            const hashIdx = sel.indexOf(\"#\");\n            const dotIdx = sel.indexOf(\".\", hashIdx);\n            const hash = hashIdx > 0 ? hashIdx : sel.length;\n            const dot = dotIdx > 0 ? dotIdx : sel.length;\n            const tag = hashIdx !== -1 || dotIdx !== -1\n                ? sel.slice(0, Math.min(hash, dot))\n                : sel;\n            const elm = (vnode.elm =\n                isDef(data) && isDef((i = data.ns))\n                    ? api.createElementNS(i, tag, data)\n                    : api.createElement(tag, data));\n            if (hash < dot)\n                elm.setAttribute(\"id\", sel.slice(hash + 1, dot));\n            if (dotIdx > 0)\n                elm.setAttribute(\"class\", sel.slice(dot + 1).replace(/\\./g, \" \"));\n            for (i = 0; i < cbs.create.length; ++i)\n                cbs.create[i](emptyNode, vnode);\n            if (is.primitive(vnode.text) &&\n                (!is.array(children) || children.length === 0)) {\n                // allow h1 and similar nodes to be created w/ text and empty child list\n                api.appendChild(elm, api.createTextNode(vnode.text));\n            }\n            if (is.array(children)) {\n                for (i = 0; i < children.length; ++i) {\n                    const ch = children[i];\n                    if (ch != null) {\n                        api.appendChild(elm, createElm(ch, insertedVnodeQueue));\n                    }\n                }\n            }\n            const hook = vnode.data.hook;\n            if (isDef(hook)) {\n                (_b = hook.create) === null || _b === void 0 ? void 0 : _b.call(hook, emptyNode, vnode);\n                if (hook.insert) {\n                    insertedVnodeQueue.push(vnode);\n                }\n            }\n        }\n        else if (((_c = options === null || options === void 0 ? void 0 : options.experimental) === null || _c === void 0 ? void 0 : _c.fragments) && vnode.children) {\n            vnode.elm = ((_d = api.createDocumentFragment) !== null && _d !== void 0 ? _d : documentFragmentIsNotSupported)();\n            for (i = 0; i < cbs.create.length; ++i)\n                cbs.create[i](emptyNode, vnode);\n            for (i = 0; i < vnode.children.length; ++i) {\n                const ch = vnode.children[i];\n                if (ch != null) {\n                    api.appendChild(vnode.elm, createElm(ch, insertedVnodeQueue));\n                }\n            }\n        }\n        else {\n            vnode.elm = api.createTextNode(vnode.text);\n        }\n        return vnode.elm;\n    }\n    function addVnodes(parentElm, before, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n        for (; startIdx <= endIdx; ++startIdx) {\n            const ch = vnodes[startIdx];\n            if (ch != null) {\n                api.insertBefore(parentElm, createElm(ch, insertedVnodeQueue), before);\n            }\n        }\n    }\n    function invokeDestroyHook(vnode) {\n        var _a, _b;\n        const data = vnode.data;\n        if (data !== undefined) {\n            (_b = (_a = data === null || data === void 0 ? void 0 : data.hook) === null || _a === void 0 ? void 0 : _a.destroy) === null || _b === void 0 ? void 0 : _b.call(_a, vnode);\n            for (let i = 0; i < cbs.destroy.length; ++i)\n                cbs.destroy[i](vnode);\n            if (vnode.children !== undefined) {\n                for (let j = 0; j < vnode.children.length; ++j) {\n                    const child = vnode.children[j];\n                    if (child != null && typeof child !== \"string\") {\n                        invokeDestroyHook(child);\n                    }\n                }\n            }\n        }\n    }\n    function removeVnodes(parentElm, vnodes, startIdx, endIdx) {\n        var _a, _b;\n        for (; startIdx <= endIdx; ++startIdx) {\n            let listeners;\n            let rm;\n            const ch = vnodes[startIdx];\n            if (ch != null) {\n                if (isDef(ch.sel)) {\n                    invokeDestroyHook(ch);\n                    listeners = cbs.remove.length + 1;\n                    rm = createRmCb(ch.elm, listeners);\n                    for (let i = 0; i < cbs.remove.length; ++i)\n                        cbs.remove[i](ch, rm);\n                    const removeHook = (_b = (_a = ch === null || ch === void 0 ? void 0 : ch.data) === null || _a === void 0 ? void 0 : _a.hook) === null || _b === void 0 ? void 0 : _b.remove;\n                    if (isDef(removeHook)) {\n                        removeHook(ch, rm);\n                    }\n                    else {\n                        rm();\n                    }\n                }\n                else if (ch.children) {\n                    // Fragment node\n                    invokeDestroyHook(ch);\n                    removeVnodes(parentElm, ch.children, 0, ch.children.length - 1);\n                }\n                else {\n                    // Text node\n                    api.removeChild(parentElm, ch.elm);\n                }\n            }\n        }\n    }\n    function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue) {\n        let oldStartIdx = 0;\n        let newStartIdx = 0;\n        let oldEndIdx = oldCh.length - 1;\n        let oldStartVnode = oldCh[0];\n        let oldEndVnode = oldCh[oldEndIdx];\n        let newEndIdx = newCh.length - 1;\n        let newStartVnode = newCh[0];\n        let newEndVnode = newCh[newEndIdx];\n        let oldKeyToIdx;\n        let idxInOld;\n        let elmToMove;\n        let before;\n        while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n            if (oldStartVnode == null) {\n                oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left\n            }\n            else if (oldEndVnode == null) {\n                oldEndVnode = oldCh[--oldEndIdx];\n            }\n            else if (newStartVnode == null) {\n                newStartVnode = newCh[++newStartIdx];\n            }\n            else if (newEndVnode == null) {\n                newEndVnode = newCh[--newEndIdx];\n            }\n            else if (sameVnode(oldStartVnode, newStartVnode)) {\n                patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n                oldStartVnode = oldCh[++oldStartIdx];\n                newStartVnode = newCh[++newStartIdx];\n            }\n            else if (sameVnode(oldEndVnode, newEndVnode)) {\n                patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n                oldEndVnode = oldCh[--oldEndIdx];\n                newEndVnode = newCh[--newEndIdx];\n            }\n            else if (sameVnode(oldStartVnode, newEndVnode)) {\n                // Vnode moved right\n                patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n                api.insertBefore(parentElm, oldStartVnode.elm, api.nextSibling(oldEndVnode.elm));\n                oldStartVnode = oldCh[++oldStartIdx];\n                newEndVnode = newCh[--newEndIdx];\n            }\n            else if (sameVnode(oldEndVnode, newStartVnode)) {\n                // Vnode moved left\n                patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n                api.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n                oldEndVnode = oldCh[--oldEndIdx];\n                newStartVnode = newCh[++newStartIdx];\n            }\n            else {\n                if (oldKeyToIdx === undefined) {\n                    oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n                }\n                idxInOld = oldKeyToIdx[newStartVnode.key];\n                if (isUndef(idxInOld)) {\n                    // `newStartVnode` is new, create and insert it in beginning\n                    api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);\n                    newStartVnode = newCh[++newStartIdx];\n                }\n                else if (isUndef(oldKeyToIdx[newEndVnode.key])) {\n                    // `newEndVnode` is new, create and insert it in the end\n                    api.insertBefore(parentElm, createElm(newEndVnode, insertedVnodeQueue), api.nextSibling(oldEndVnode.elm));\n                    newEndVnode = newCh[--newEndIdx];\n                }\n                else {\n                    // Neither of the new endpoints are new vnodes, so we make progress by\n                    // moving `newStartVnode` into position\n                    elmToMove = oldCh[idxInOld];\n                    if (elmToMove.sel !== newStartVnode.sel) {\n                        api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);\n                    }\n                    else {\n                        patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\n                        oldCh[idxInOld] = undefined;\n                        api.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);\n                    }\n                    newStartVnode = newCh[++newStartIdx];\n                }\n            }\n        }\n        if (newStartIdx <= newEndIdx) {\n            before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm;\n            addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n        }\n        if (oldStartIdx <= oldEndIdx) {\n            removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n        }\n    }\n    function patchVnode(oldVnode, vnode, insertedVnodeQueue) {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        const hook = (_a = vnode.data) === null || _a === void 0 ? void 0 : _a.hook;\n        (_b = hook === null || hook === void 0 ? void 0 : hook.prepatch) === null || _b === void 0 ? void 0 : _b.call(hook, oldVnode, vnode);\n        const elm = (vnode.elm = oldVnode.elm);\n        if (oldVnode === vnode)\n            return;\n        if (vnode.data !== undefined ||\n            (isDef(vnode.text) && vnode.text !== oldVnode.text)) {\n            (_c = vnode.data) !== null && _c !== void 0 ? _c : (vnode.data = {});\n            (_d = oldVnode.data) !== null && _d !== void 0 ? _d : (oldVnode.data = {});\n            for (let i = 0; i < cbs.update.length; ++i)\n                cbs.update[i](oldVnode, vnode);\n            (_g = (_f = (_e = vnode.data) === null || _e === void 0 ? void 0 : _e.hook) === null || _f === void 0 ? void 0 : _f.update) === null || _g === void 0 ? void 0 : _g.call(_f, oldVnode, vnode);\n        }\n        const oldCh = oldVnode.children;\n        const ch = vnode.children;\n        if (isUndef(vnode.text)) {\n            if (isDef(oldCh) && isDef(ch)) {\n                if (oldCh !== ch)\n                    updateChildren(elm, oldCh, ch, insertedVnodeQueue);\n            }\n            else if (isDef(ch)) {\n                if (isDef(oldVnode.text))\n                    api.setTextContent(elm, \"\");\n                addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n            }\n            else if (isDef(oldCh)) {\n                removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n            }\n            else if (isDef(oldVnode.text)) {\n                api.setTextContent(elm, \"\");\n            }\n        }\n        else if (oldVnode.text !== vnode.text) {\n            if (isDef(oldCh)) {\n                removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n            }\n            api.setTextContent(elm, vnode.text);\n        }\n        (_h = hook === null || hook === void 0 ? void 0 : hook.postpatch) === null || _h === void 0 ? void 0 : _h.call(hook, oldVnode, vnode);\n    }\n    return function patch(oldVnode, vnode) {\n        let i, elm, parent;\n        const insertedVnodeQueue = [];\n        for (i = 0; i < cbs.pre.length; ++i)\n            cbs.pre[i]();\n        if (isElement(api, oldVnode)) {\n            oldVnode = emptyNodeAt(oldVnode);\n        }\n        else if (isDocumentFragment(api, oldVnode)) {\n            oldVnode = emptyDocumentFragmentAt(oldVnode);\n        }\n        if (sameVnode(oldVnode, vnode)) {\n            patchVnode(oldVnode, vnode, insertedVnodeQueue);\n        }\n        else {\n            elm = oldVnode.elm;\n            parent = api.parentNode(elm);\n            createElm(vnode, insertedVnodeQueue);\n            if (parent !== null) {\n                api.insertBefore(parent, vnode.elm, api.nextSibling(elm));\n                removeVnodes(parent, [oldVnode], 0, 0);\n            }\n        }\n        for (i = 0; i < insertedVnodeQueue.length; ++i) {\n            insertedVnodeQueue[i].data.hook.insert(insertedVnodeQueue[i]);\n        }\n        for (i = 0; i < cbs.post.length; ++i)\n            cbs.post[i]();\n        return vnode;\n    };\n}\n//# sourceMappingURL=init.js.map","export const array = Array.isArray;\nexport function primitive(s) {\n    return (typeof s === \"string\" ||\n        typeof s === \"number\" ||\n        s instanceof String ||\n        s instanceof Number);\n}\n//# sourceMappingURL=is.js.map","import { vnode } from \"./vnode.js\";\nimport { h } from \"./h.js\";\nexport function Fragment(data, ...children) {\n    const flatChildren = flattenAndFilter(children, []);\n    if (flatChildren.length === 1 &&\n        !flatChildren[0].sel &&\n        flatChildren[0].text) {\n        // only child is a simple text node, pass as text for a simpler vtree\n        return vnode(undefined, undefined, undefined, flatChildren[0].text, undefined);\n    }\n    else {\n        return vnode(undefined, data !== null && data !== void 0 ? data : {}, flatChildren, undefined, undefined);\n    }\n}\nfunction flattenAndFilter(children, flattened) {\n    for (const child of children) {\n        // filter out falsey children, except 0 since zero can be a valid value e.g inside a chart\n        if (child !== undefined &&\n            child !== null &&\n            child !== false &&\n            child !== \"\") {\n            if (Array.isArray(child)) {\n                flattenAndFilter(child, flattened);\n            }\n            else if (typeof child === \"string\" ||\n                typeof child === \"number\" ||\n                typeof child === \"boolean\") {\n                flattened.push(vnode(undefined, undefined, undefined, String(child), undefined));\n            }\n            else {\n                flattened.push(child);\n            }\n        }\n    }\n    return flattened;\n}\n/**\n * jsx/tsx compatible factory function\n * see: https://www.typescriptlang.org/docs/handbook/jsx.html#factory-functions\n */\nexport function jsx(tag, data, ...children) {\n    const flatChildren = flattenAndFilter(children, []);\n    if (typeof tag === \"function\") {\n        // tag is a function component\n        return tag(data, flatChildren);\n    }\n    else {\n        if (flatChildren.length === 1 &&\n            !flatChildren[0].sel &&\n            flatChildren[0].text) {\n            // only child is a simple text node, pass as text for a simpler vtree\n            return h(tag, data, flatChildren[0].text);\n        }\n        else {\n            return h(tag, data, flatChildren);\n        }\n    }\n}\n//# sourceMappingURL=jsx.js.map","const xlinkNS = \"http://www.w3.org/1999/xlink\";\nconst xmlnsNS = \"http://www.w3.org/2000/xmlns/\";\nconst xmlNS = \"http://www.w3.org/XML/1998/namespace\";\nconst colonChar = 58;\nconst xChar = 120;\nconst mChar = 109;\nfunction updateAttrs(oldVnode, vnode) {\n    let key;\n    const elm = vnode.elm;\n    let oldAttrs = oldVnode.data.attrs;\n    let attrs = vnode.data.attrs;\n    if (!oldAttrs && !attrs)\n        return;\n    if (oldAttrs === attrs)\n        return;\n    oldAttrs = oldAttrs || {};\n    attrs = attrs || {};\n    // update modified attributes, add new attributes\n    for (key in attrs) {\n        const cur = attrs[key];\n        const old = oldAttrs[key];\n        if (old !== cur) {\n            if (cur === true) {\n                elm.setAttribute(key, \"\");\n            }\n            else if (cur === false) {\n                elm.removeAttribute(key);\n            }\n            else {\n                if (key.charCodeAt(0) !== xChar) {\n                    elm.setAttribute(key, cur);\n                }\n                else if (key.charCodeAt(3) === colonChar) {\n                    // Assume xml namespace\n                    elm.setAttributeNS(xmlNS, key, cur);\n                }\n                else if (key.charCodeAt(5) === colonChar) {\n                    // Assume 'xmlns' or 'xlink' namespace\n                    key.charCodeAt(1) === mChar\n                        ? elm.setAttributeNS(xmlnsNS, key, cur)\n                        : elm.setAttributeNS(xlinkNS, key, cur);\n                }\n                else {\n                    elm.setAttribute(key, cur);\n                }\n            }\n        }\n    }\n    // remove removed attributes\n    // use `in` operator since the previous `for` iteration uses it (.i.e. add even attributes with undefined value)\n    // the other option is to remove all attributes with value == undefined\n    for (key in oldAttrs) {\n        if (!(key in attrs)) {\n            elm.removeAttribute(key);\n        }\n    }\n}\nexport const attributesModule = {\n    create: updateAttrs,\n    update: updateAttrs\n};\n//# sourceMappingURL=attributes.js.map","function updateClass(oldVnode, vnode) {\n    let cur;\n    let name;\n    const elm = vnode.elm;\n    let oldClass = oldVnode.data.class;\n    let klass = vnode.data.class;\n    if (!oldClass && !klass)\n        return;\n    if (oldClass === klass)\n        return;\n    oldClass = oldClass || {};\n    klass = klass || {};\n    for (name in oldClass) {\n        if (oldClass[name] && !Object.prototype.hasOwnProperty.call(klass, name)) {\n            // was `true` and now not provided\n            elm.classList.remove(name);\n        }\n    }\n    for (name in klass) {\n        cur = klass[name];\n        if (cur !== oldClass[name]) {\n            elm.classList[cur ? \"add\" : \"remove\"](name);\n        }\n    }\n}\nexport const classModule = { create: updateClass, update: updateClass };\n//# sourceMappingURL=class.js.map","const CAPS_REGEX = /[A-Z]/g;\nfunction updateDataset(oldVnode, vnode) {\n    const elm = vnode.elm;\n    let oldDataset = oldVnode.data.dataset;\n    let dataset = vnode.data.dataset;\n    let key;\n    if (!oldDataset && !dataset)\n        return;\n    if (oldDataset === dataset)\n        return;\n    oldDataset = oldDataset || {};\n    dataset = dataset || {};\n    const d = elm.dataset;\n    for (key in oldDataset) {\n        if (!(key in dataset)) {\n            if (d) {\n                if (key in d) {\n                    delete d[key];\n                }\n            }\n            else {\n                elm.removeAttribute(\"data-\" + key.replace(CAPS_REGEX, \"-$&\").toLowerCase());\n            }\n        }\n    }\n    for (key in dataset) {\n        if (oldDataset[key] !== dataset[key]) {\n            if (d) {\n                d[key] = dataset[key];\n            }\n            else {\n                elm.setAttribute(\"data-\" + key.replace(CAPS_REGEX, \"-$&\").toLowerCase(), dataset[key]);\n            }\n        }\n    }\n}\nexport const datasetModule = {\n    create: updateDataset,\n    update: updateDataset\n};\n//# sourceMappingURL=dataset.js.map","function invokeHandler(handler, vnode, event) {\n    if (typeof handler === \"function\") {\n        // call function handler\n        handler.call(vnode, event, vnode);\n    }\n    else if (typeof handler === \"object\") {\n        // call multiple handlers\n        for (let i = 0; i < handler.length; i++) {\n            invokeHandler(handler[i], vnode, event);\n        }\n    }\n}\nfunction handleEvent(event, vnode) {\n    const name = event.type;\n    const on = vnode.data.on;\n    // call event handler(s) if exists\n    if (on && on[name]) {\n        invokeHandler(on[name], vnode, event);\n    }\n}\nfunction createListener() {\n    return function handler(event) {\n        handleEvent(event, handler.vnode);\n    };\n}\nfunction updateEventListeners(oldVnode, vnode) {\n    const oldOn = oldVnode.data.on;\n    const oldListener = oldVnode.listener;\n    const oldElm = oldVnode.elm;\n    const on = vnode && vnode.data.on;\n    const elm = (vnode && vnode.elm);\n    let name;\n    // optimization for reused immutable handlers\n    if (oldOn === on) {\n        return;\n    }\n    // remove existing listeners which no longer used\n    if (oldOn && oldListener) {\n        // if element changed or deleted we remove all existing listeners unconditionally\n        if (!on) {\n            for (name in oldOn) {\n                // remove listener if element was changed or existing listeners removed\n                oldElm.removeEventListener(name, oldListener, false);\n            }\n        }\n        else {\n            for (name in oldOn) {\n                // remove listener if existing listener removed\n                if (!on[name]) {\n                    oldElm.removeEventListener(name, oldListener, false);\n                }\n            }\n        }\n    }\n    // add new listeners which has not already attached\n    if (on) {\n        // reuse existing listener or create new\n        const listener = (vnode.listener =\n            oldVnode.listener || createListener());\n        // update vnode for listener\n        listener.vnode = vnode;\n        // if element changed or added we add all needed listeners unconditionally\n        if (!oldOn) {\n            for (name in on) {\n                // add listener if element was changed or new listeners added\n                elm.addEventListener(name, listener, false);\n            }\n        }\n        else {\n            for (name in on) {\n                // add listener if new listener added\n                if (!oldOn[name]) {\n                    elm.addEventListener(name, listener, false);\n                }\n            }\n        }\n    }\n}\nexport const eventListenersModule = {\n    create: updateEventListeners,\n    update: updateEventListeners,\n    destroy: updateEventListeners\n};\n//# sourceMappingURL=eventlisteners.js.map","function updateProps(oldVnode, vnode) {\n    let key;\n    let cur;\n    let old;\n    const elm = vnode.elm;\n    let oldProps = oldVnode.data.props;\n    let props = vnode.data.props;\n    if (!oldProps && !props)\n        return;\n    if (oldProps === props)\n        return;\n    oldProps = oldProps || {};\n    props = props || {};\n    for (key in props) {\n        cur = props[key];\n        old = oldProps[key];\n        if (old !== cur && (key !== \"value\" || elm[key] !== cur)) {\n            elm[key] = cur;\n        }\n    }\n}\nexport const propsModule = { create: updateProps, update: updateProps };\n//# sourceMappingURL=props.js.map","// Binding `requestAnimationFrame` like this fixes a bug in IE/Edge. See #360 and #409.\nconst raf = typeof (window === null || window === void 0 ? void 0 : window.requestAnimationFrame) === \"function\"\n    ? window.requestAnimationFrame.bind(window)\n    : setTimeout;\nconst nextFrame = function (fn) {\n    raf(function () {\n        raf(fn);\n    });\n};\nlet reflowForced = false;\nfunction setNextFrame(obj, prop, val) {\n    nextFrame(function () {\n        obj[prop] = val;\n    });\n}\nfunction updateStyle(oldVnode, vnode) {\n    let cur;\n    let name;\n    const elm = vnode.elm;\n    let oldStyle = oldVnode.data.style;\n    let style = vnode.data.style;\n    if (!oldStyle && !style)\n        return;\n    if (oldStyle === style)\n        return;\n    oldStyle = oldStyle || {};\n    style = style || {};\n    const oldHasDel = \"delayed\" in oldStyle;\n    for (name in oldStyle) {\n        if (!(name in style)) {\n            if (name[0] === \"-\" && name[1] === \"-\") {\n                elm.style.removeProperty(name);\n            }\n            else {\n                elm.style[name] = \"\";\n            }\n        }\n    }\n    for (name in style) {\n        cur = style[name];\n        if (name === \"delayed\" && style.delayed) {\n            for (const name2 in style.delayed) {\n                cur = style.delayed[name2];\n                if (!oldHasDel || cur !== oldStyle.delayed[name2]) {\n                    setNextFrame(elm.style, name2, cur);\n                }\n            }\n        }\n        else if (name !== \"remove\" && cur !== oldStyle[name]) {\n            if (name[0] === \"-\" && name[1] === \"-\") {\n                elm.style.setProperty(name, cur);\n            }\n            else {\n                elm.style[name] = cur;\n            }\n        }\n    }\n}\nfunction applyDestroyStyle(vnode) {\n    let style;\n    let name;\n    const elm = vnode.elm;\n    const s = vnode.data.style;\n    if (!s || !(style = s.destroy))\n        return;\n    for (name in style) {\n        elm.style[name] = style[name];\n    }\n}\nfunction applyRemoveStyle(vnode, rm) {\n    const s = vnode.data.style;\n    if (!s || !s.remove) {\n        rm();\n        return;\n    }\n    if (!reflowForced) {\n        // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n        vnode.elm.offsetLeft;\n        reflowForced = true;\n    }\n    let name;\n    const elm = vnode.elm;\n    let i = 0;\n    const style = s.remove;\n    let amount = 0;\n    const applied = [];\n    for (name in style) {\n        applied.push(name);\n        elm.style[name] = style[name];\n    }\n    const compStyle = getComputedStyle(elm);\n    const props = compStyle[\"transition-property\"].split(\", \");\n    for (; i < props.length; ++i) {\n        if (applied.indexOf(props[i]) !== -1)\n            amount++;\n    }\n    elm.addEventListener(\"transitionend\", function (ev) {\n        if (ev.target === elm)\n            --amount;\n        if (amount === 0)\n            rm();\n    });\n}\nfunction forceReflow() {\n    reflowForced = false;\n}\nexport const styleModule = {\n    pre: forceReflow,\n    create: updateStyle,\n    update: updateStyle,\n    destroy: applyDestroyStyle,\n    remove: applyRemoveStyle\n};\n//# sourceMappingURL=style.js.map","import { h, addNS } from \"./h.js\";\nfunction copyToThunk(vnode, thunk) {\n    var _a;\n    const ns = (_a = thunk.data) === null || _a === void 0 ? void 0 : _a.ns;\n    vnode.data.fn = thunk.data.fn;\n    vnode.data.args = thunk.data.args;\n    thunk.data = vnode.data;\n    thunk.children = vnode.children;\n    thunk.text = vnode.text;\n    thunk.elm = vnode.elm;\n    if (ns)\n        addNS(thunk.data, thunk.children, thunk.sel);\n}\nfunction init(thunk) {\n    const cur = thunk.data;\n    const vnode = cur.fn(...cur.args);\n    copyToThunk(vnode, thunk);\n}\nfunction prepatch(oldVnode, thunk) {\n    let i;\n    const old = oldVnode.data;\n    const cur = thunk.data;\n    const oldArgs = old.args;\n    const args = cur.args;\n    if (old.fn !== cur.fn || oldArgs.length !== args.length) {\n        copyToThunk(cur.fn(...args), thunk);\n        return;\n    }\n    for (i = 0; i < args.length; ++i) {\n        if (oldArgs[i] !== args[i]) {\n            copyToThunk(cur.fn(...args), thunk);\n            return;\n        }\n    }\n    copyToThunk(oldVnode, thunk);\n}\nexport const thunk = function thunk(sel, key, fn, args) {\n    if (args === undefined) {\n        args = fn;\n        fn = key;\n        key = undefined;\n    }\n    return h(sel, {\n        key: key,\n        hook: { init, prepatch },\n        fn: fn,\n        args: args\n    });\n};\n//# sourceMappingURL=thunk.js.map","import { addNS } from \"./h.js\";\nimport { vnode } from \"./vnode.js\";\nimport { htmlDomApi } from \"./htmldomapi.js\";\nexport function toVNode(node, domApi) {\n    const api = domApi !== undefined ? domApi : htmlDomApi;\n    let text;\n    if (api.isElement(node)) {\n        const id = node.id ? \"#\" + node.id : \"\";\n        const cn = node.getAttribute(\"class\");\n        const c = cn ? \".\" + cn.split(\" \").join(\".\") : \"\";\n        const sel = api.tagName(node).toLowerCase() + id + c;\n        const attrs = {};\n        const dataset = {};\n        const data = {};\n        const children = [];\n        let name;\n        let i, n;\n        const elmAttrs = node.attributes;\n        const elmChildren = node.childNodes;\n        for (i = 0, n = elmAttrs.length; i < n; i++) {\n            name = elmAttrs[i].nodeName;\n            if (name.startsWith(\"data-\")) {\n                dataset[name.slice(5)] = elmAttrs[i].nodeValue || \"\";\n            }\n            else if (name !== \"id\" && name !== \"class\") {\n                attrs[name] = elmAttrs[i].nodeValue;\n            }\n        }\n        for (i = 0, n = elmChildren.length; i < n; i++) {\n            children.push(toVNode(elmChildren[i], domApi));\n        }\n        if (Object.keys(attrs).length > 0)\n            data.attrs = attrs;\n        if (Object.keys(dataset).length > 0)\n            data.dataset = dataset;\n        if (sel.startsWith(\"svg\") &&\n            (sel.length === 3 || sel[3] === \".\" || sel[3] === \"#\")) {\n            addNS(data, children, sel);\n        }\n        return vnode(sel, data, children, undefined, node);\n    }\n    else if (api.isText(node)) {\n        text = api.getTextContent(node);\n        return vnode(undefined, undefined, undefined, text, node);\n    }\n    else if (api.isComment(node)) {\n        text = api.getTextContent(node);\n        return vnode(\"!\", {}, [], text, node);\n    }\n    else {\n        return vnode(\"\", {}, [], undefined, node);\n    }\n}\n//# sourceMappingURL=tovnode.js.map","export function vnode(sel, data, children, text, elm) {\n    const key = data === undefined ? undefined : data.key;\n    return { sel, data, children, text, elm, key };\n}\n//# sourceMappingURL=vnode.js.map","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./static/input/ui.ts\");\n",""],"names":[],"sourceRoot":""}